---
title: 装饰器模式
tags:
  - common
  - design-pattern
  - decorator
---
## 概述
装饰器不是为了解决不能用的问题，而是为了解决不想改却要增强的问题。典型场景就是日志、权限校验、事务、缓存等。在这些场景里，如果不使用装饰器，只能在业务的基础上直接修改类，这会造成业务逻辑污染，违反单一原则；或是使用继承，但会容易导致子类爆炸；又或是拷贝代码，这更是不可维护。装饰器解决的是在不修改、不继承的前提下，组合行为。
## 核心结构
关键只有一条装饰器和被装饰对象，是同一个接口类型。
```
Component（接口）
    ↑
ConcreteComponent（原始实现）
    ↑
Decorator（持有 Component）
    ↑
ConcreteDecorator（增强行为）
```
两者是以组合的形式存在的，所以在代码层面与许多模式的结构类似，但其意图不同。
```java
class XxxDecorator implements Service {
    private final Service delegate;
}
```
## 现状
工程视角下，装饰器具有不可替代性。行为组合这个问题依然存在，而且越来越严重。所以装饰器模式至今仍未淘汰，仍然广泛使用。Java 的 IO 流仍然保留着装饰器风格的实例设计。这种结构使得每一层只做一件事，而且层数不多没有产生爆炸问题。
```java
InputStream in =
    new BufferedInputStream(
        new DataInputStream(
            new FileInputStream(file)
        )
    );
```
但由于装饰器模式可以多层嵌套的特性导致了手写嵌套关系有失控的风险，所以现在的装饰器模式都是以框架和语言层级存在的，通过自动的生成来执行这种嵌套，而使用者通过一系列的声明进行管理，使得整体流程变得可控。由于各个语言实现装饰器模式的具体机制和语法并不同，这里不展开说明，但在编程风格上以两种为主，如下。其实
- 以 Java 为代表的基于框架的实现，通过注解 + 框架实现。
- 以函数式编程为主的，如 Python 、Kotlin 、TypeScript 等，以函数的包裹实现，一般是语言级别的机制，更为详细的机制各有不同。
## 辨析
装饰器由于实现结构与适配器模式相似，所以容易产生混淆。见 [适配器模式与装饰器模式辨析](design-pattern-adapter.md#与装饰器模式辨析) 。
