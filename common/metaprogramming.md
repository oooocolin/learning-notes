---
title: 元编程
tags:
  - common
---
## 概述
元编程（Metaprogramming）是编写操作、生成或修改其他程序甚至是自身的程序。元编程分为编译时和运行时。
- 编译时元编程：在编译阶段生成代码，如 C++ 模板、宏等。
- 运行时元编程：装饰器、动态代理等
## 常见应用机制
### 反射
反射可以实现在程序运行时进行检查或者修改自身结构和内容。
```java
// Java反射动态调用方法
Class<?> clazz = MyClass.class;
Method method = clazz.getMethod("methodName");
method.invoke(clazz.newInstance());
```
### 宏
宏在编译前使用预定义的代码模板生成代码。
### 模板
模板是在编译时使用预定义的代码模板生成代码，是真正的泛型编程。
### 元类
控制类的创建过程，实现类级别的行为定制。
### 动态代码生成
通过使用字符串或代码对象动态执行代码。
```python
dynamic_code = "print(1+2+3)"
eval(dynamic_code)  # 输出：6
```
## 典型的应用场景
### 框架与库的开发
- Spring AOP：使用动态代理实现事务管理、日志管理等其他面向切面编程等操作。
- MyBatis等ORM：根据注解动态生成数据库查询方法。
### 减少样板代码
- Java Lombok：通过注解生成 Getter/Setter/构造函数。
### 动态行为扩展
- JavaScript Proxy：拦截对象属性访问。
```js
const target = { x: 10 };
const proxy = new Proxy(target, {
	get(target, prop) {
	    console.log(`访问属性: ${prop}`);
	    return target[prop];
	}
});
console.log(proxy.x);
```
### 插桩与性能分析
- 自动注入性能监控、调试信息
## 最佳实践
### 明确设计需求
元编程需要在不牺牲可维护性的前提下，实现高层次的抽象与自动化。具体而言有三类动机：
- 去除重复（自动注册、自动验证，不需要写重复的样板逻辑）；
- 动态扩展（AOP、日志、监控、权限，在不修改原逻辑的情况下增加功能）；
- 创建声明式编程接口（ORM、配置式框架，让用户声明要什么，框架自动生成逻辑）。
元编程应该服务于抽象设计，而不是炫技和省几行代码。
### 合理使用
一般来说按照工作的规模和强度来选择元编程的具体实现方法：
- 轻量级
	- 技术手段：反射、装饰器、函数包装。
	- 场景：日志、验证、缓存。
- 中量级：
	- 技术手段：类注册表、自动工厂、动态属性。
	- 场景：框架组件管理。
- 重量级：
	- 技术手段：元类、动态代码生成。
	- 场景：ORM 、代码生成器、动态语言实现。
### 原则
- 最小化影响范围。不要让元编程逻辑渗透到业务代码中，应在框架层隔离。  
- 可读性优先。如果别人读不懂，就等于写坏了。
- 可替代性。设计时考虑如果移除元编程是否能正常运行（方便调试）。
- 显式优于隐式（Python之禅）。尽量让动态行为通过命名或标记体现，例如用装饰器明示。
- 文档化与测试覆盖。必须清楚说明它修改了什么、何时修改。
