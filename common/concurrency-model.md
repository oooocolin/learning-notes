---
title: 多线程模型
tags:
  - common
  - concurrency
---
## 一、概述
并发就是通过代码编程让计算机在一定时间内同时跑多个程序所进行的编程操作。一般并发的实现一般有三种：进程、线程、协程。进程是是操作系统资源分配和独立运行的最小单位；线程是进程内的一个任务执行独立单元，是任务调度和系统执行的最小单位；协程是用户态的轻量级线程，协程的调度完全由用户控制，主要为了单线程下模拟多线程。
## 二、线程的实现
### 1. 线程模型的实现
一般常见的语言默认支持的多线程模型都是占有式多线程模型，比如 Java 、C++ 、Python 等。占用式多线程是多个线程共享同一块内存空间，线程之间直接访问和修改共享变量，但需要通过锁、信号量等方式同步数据。但是一般这种抢占式多线程很大一部分开销在于锁竞争和切换，锁的细粒度直接影响最终的性能和结果。  
而通信式多线程是每个线程都有自己独立的内存和状态，不直接访问彼此的内存，而是通过消息传递来交流数据同步状态，其消息一般通过队列 / Channel / Mailbox 传递，消息本身是拷贝发送或是不可修改的引用发送使用，这样天然避免了数据竞争。这种实现方式一般在 Go 、 Rust 的某些模型中实现，以及 Java 的某些库的实现，主要分为两个方向 Actor 模型和 CSP模型。
### 2. 模型选用
对于占用式多线程有以下特点：
- 单机性能最高（直接访问内存，无序列化/拷贝开销）；
- 线程竞争资源时性能急剧下降。
对于通信式多线程有以下特点：
- 相较于抢占式多线程性能稍慢，但更稳定；
- 发送信息通常涉及队列操作、数据拷贝、上下文切换等，不过可并行化更好，延展性强；
- 实际执行的瓶颈在于通信的成本。
根据以上特点，当少量线程、密集计算、低冲突时使用抢占式的多线程更快，高并发、分布式、I/O多、扩展性要求高的建议使用通信式多线程。按照目前行业的趋势来看，通信式多线程会是将来发展使用的方向。大致有以下理由：
- 共享内存模式扩展性很差，在多核很普及的现状下，锁竞争在高核数下放大得很快；
- Actor 模型更易维护、调试、推理，软件工程复杂性较低；
- 消息通信天生适合分布式，通信式多线程可以无缝迁移到集群。
### 3. Actor 模型与 CSP 模型
两个模型都是通信式并发模型，都是基于消息传递共享的资源，但是两者在结构上有所区别：
- Actor 模型：每个 Actor 拥有自己的邮箱（Mailbox），其他线程直接发消息到邮箱。
- CSP 模型：没有邮箱，而是通过公共的通道（Channel）进行交换消息。
具体的实现参照 [Actor 模型](actor-model.md) 




