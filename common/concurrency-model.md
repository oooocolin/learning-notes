---
title: 并发模型
tags:
  - common
  - concurrency
---
## 概述
并发就是通过代码编程让计算机在一定时间内同时跑多个程序所进行的编程操作。一般并发的实现一般有三种：进程、线程、协程。进程是是操作系统资源分配和独立运行的最小单位；线程是进程内的一个任务执行独立单元，是任务调度和系统执行的最小单位；协程是用户态的轻量级线程，协程的调度完全由用户控制，主要为了单线程下模拟多线程。
## 线程的实现
### 线程模型的实现
一般常见的语言默认支持的多线程模型都是占有式多线程模型，比如 Java 、C++ 、Python 等。占用式多线程是多个线程共享同一块内存空间，线程之间直接访问和修改共享变量，但需要通过锁、信号量等方式同步数据。但是一般这种抢占式多线程很大一部分开销在于锁竞争和切换，锁的细粒度直接影响最终的性能和结果。  
而通信式多线程是每个线程都有自己独立的内存和状态，不直接访问彼此的内存，而是通过消息传递来交流数据同步状态，其消息一般通过队列 / Channel / Mailbox 传递，消息本身是拷贝发送或是不可修改的引用发送使用，这样天然避免了数据竞争。这种实现方式一般在 Go 、 Rust 的某些模型中实现，以及 Java 的某些库的实现，主要分为两个方向 Actor 模型和 CSP模型。
### 模型选用
对于占用式多线程有以下特点：
- 单机性能最高（直接访问内存，无序列化/拷贝开销）；
- 线程竞争资源时性能急剧下降。
对于通信式多线程有以下特点：
- 相较于抢占式多线程性能稍慢，但更稳定；
- 发送信息通常涉及队列操作、数据拷贝、上下文切换等，不过可并行化更好，延展性强；
- 实际执行的瓶颈在于通信的成本。
根据以上特点，当少量线程、密集计算、低冲突时使用抢占式的多线程更快，高并发、分布式、I/O多、扩展性要求高的建议使用通信式多线程。按照目前行业的趋势来看，通信式多线程会是将来发展使用的方向。大致有以下理由：
- 共享内存模式扩展性很差，在多核很普及的现状下，锁竞争在高核数下放大得很快；
- Actor 模型更易维护、调试、推理，软件工程复杂性较低；
- 消息通信天生适合分布式，通信式多线程可以无缝迁移到集群。
### Actor 模型与 CSP 模型
两个模型都是通信式并发模型，都是基于消息传递共享的资源，但是两者在结构上有所区别：
- Actor 模型：每个 Actor 拥有自己的邮箱（Mailbox），其他线程直接发消息到邮箱。
- CSP 模型：没有邮箱，而是通过公共的通道（Channel）进行交换消息。
具体的实现参照 [Actor 模型](actor-model.md) 

## 协程
协程可以理解为一种可以在函数执行过程中暂停和恢复的执行单元。协程不是在系统层面抢占时间片，而是由程序（或框架）在某些点主动挂起和恢复。这使得它在高并发、IO密集的场景下效率极高（如网络服务器、异步请求、游戏引擎脚本等）。其本质是：
- 保存函数执行栈的上下文（指令指针、局部变量状态）；
- 在挂起时存储当前状态；
- 在恢复时重新载入状态。
协程服务于线程中可并行但逻辑独立的部分（如果没有这个条件，则不需要使用协程），典型场景就是需要等待挂起的场景，比如：
- 网络 I/O（HTTP 请求、数据库查询、Socket 连接）；
- 文件 I/O（读写文件、磁盘操作）；
- 定时等待（sleep、延时、动画帧等待）。
协程比较典型的实现就是 Python 和 JavaScript 的异步编程，其背后执行的机制就是协程。`async/await` 机制的 `await` 就是将协程挂起，但不阻塞线程执行。现代的 Actor / CSP 模型虽然理念上不是依赖协程，但是在工程实现上几乎以协程为基础来构建，尤其是任务调度单元（但其底层还是要落在线程执行）。
