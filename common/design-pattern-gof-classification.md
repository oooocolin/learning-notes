---
title: GoF 23 种设计模式新分类
tags:
  - common
  - design-pattern
---
## 概述
GoF 式的设计模式在现代语言编程中已经被语言和框架吞并，在当今工程中要想能从中获取设计层面的参考，并且不使我们在使用中不合适的硬套传统设计模式的使用方法，需要对原有 GoF 设计模式进行重新分类，分类依据以工程实现和当今指导工程的实际价值来进行。
## 已经废弃的模式
### [原型模式](design-pattern-prototype.md) 
在实例对象创建的成本大幅度降低的现代工程中，原型模式的存在基础已经不复存在，这个模式是完完全全的淘汰的设计模式。
### [抽象工厂模式](design-pattern-factory.md#抽象工厂模式) 
抽象设想产品族是稳定的、可枚举、长期一致的，这一点在真实的工程中几乎不成立，所以抽象工厂模式在业务和框架层面抽象工厂都不成立。Spring 也没有使用抽象工厂，而是工厂 + 注册表 + 生命周期管理器的重型结构。所以抽象工厂模式在当今工程中被废弃，成为只存在教科书中存在的模式。
### [桥接模式](dp-adapter-bridge-facade.md#桥接模式) 
由于来源编程原则的语义膨胀，面向接口编程以及组合优于继承的原则思想影响的扩大，桥接模式作为一个单独模式的基础已经不复存在。
### [外观模式](dp-adapter-bridge-facade.md#外观模式) 
由于向高层提供更友好更简便的封装原则自然向系统层级语义膨胀，外观模式已被封装原则吞噬，作为一个单独设计模式已经没有存在的必要。
### [迭代器模式](dp-command-iterator-interpreter.md#迭代器模式) 
迭代器模式基本已被语言原生特性取代，和原型模式处境类似，可以算是完全淘汰。
### [访问者模式](dp-observer-mediator-visitor.md#访问者模式) 
访问者模式将数据与行为进行拆分，直接破坏了结构，对业务变化极不友好，在工程中极不推荐，只剩下教学价值。
## 升级或仍沿用的模式
### [装饰器模式](dp-proxy-decorator.md#装饰器模式) 
装饰器模式在机制上得到升级使得嵌套关系得到控制，以声明式语法糖 `@` 在各种语言上由机制呈现，使得装饰器模式在当今工程中承担重要角色，尤其是进行 AOP 操作装饰器模式以及相关语法机制更为活跃。
### [代理模式](dp-proxy-decorator.md#代理模式) 
对对象进行控制访问，必须依靠代理模式，而且在当今工程注重 DI 容器的情况下，若需要自行实现 DI 容器代理模式也是其强大的支持，主要体现在对实例对象的动态代理中体现。至今仍然是作为基础的机制或是基础实现而存在于业务框架中。
### [适配器模式](dp-adapter-bridge-facade.md#适配器模式) 
适配器专门解决系统边界问题，这个问题无法解决，而且在现代工程中越来越常见，是解决第三方 SDK 能否使用的问题，所以适配器模式是再现代工程中永远不会淘汰的设计模式。
### [观察者模式](dp-observer-mediator-visitor.md#观察者模式) 
观察者模式在当今工程中是行为型中生命力最强的模式，只是和语言机制结合在一起，一般的框架或是平台支持这一机制，尤其在现代移动端开发中经常用在 UI 数据的监控和响应刷新的机制层面，比如 SwiftUI 的 `@ObservedObject` 。
### [命令模式](dp-command-iterator-interpreter.md#命令模式) 
行为封装成对象，这在当今分布式操作场景中逐渐变得重要。
## 思想沿用，实现改造的设计模式
### [单例模式](design-pattern-singleton.md) 
单例的需求依然存在，但写单例类的实现已经不推荐了，在语言层面结合模块和导出对象或是以 DI 容器存在实现语义单例，而不是结构上的单例实现是更好的方案。
### [工厂模式](design-pattern-factory.md) 
显式的工厂的价值在业务中没有必要了，一般工程使用 `Map<key, Supplier>` 的形式或是 DI 容器实现是更好的做法。
### [策略模式](dp-strategy-status.md#策略模式) 
策略模式设计在现代工程中使用函数 / Lambda 或是 `Map<key, strategy>` 进行精简使用。
### [状态模式](dp-strategy-status.md#状态模式) 
状态模式原实现过重了，结构十分臃肿。现代工程中使用 Enum + Map 或是状态机实现替代。
### [备忘录模式](dp-chain_of_resp-memento.md#备忘录模式) 
状态可恢复的需求不会消失，备忘录模式一般而言不会消失。但是在现代工程中不显式地去写 备忘录类了，而是变成 Snapshot 语法更轻。
## 高度框架化，已不自行实现的模式
### [模板方法模式](design-pattern-template.md) 
模板方法模式已经在框架内使用，对于现代工程来说，一般是去使用这些模板，而不是自己去创建模板。所以这个模式更多的是来进行识别模式的使用。其内部也部分使用 Lambda / 回调进行轻量化处理，实现更方便的调用。
### [责任链模式](dp-chain_of_resp-memento.md#责任链模式) 
责任链在 Filter 中使用，在框架的拦截器等链式处理的操作存在，这已经高度框架化，业务层级的没必要实现，框架层级的没必要自己实现。
### [中介模式](dp-observer-mediator-visitor.md#中介模式) 
中介模式在现代工程中多见于系统级设计，而非普通业务类。不再作为一种类设计而存在，而是作为一种消息中枢的设计而存在的。
## 只在特殊场景使用的模式
### [建造者模式](design-pattern-builder.md) 
建造者模式现在只作为特定的实现，比如网络复杂参数构造，一般而言不会主动去书写实现这个模式。一般复杂的建造使用命名参数、对象字面量、默认值等机制实现，而不是使用建造者模式。
### [组合模式](dp-composite-flyweight.md#组合模式) 
组合模式现在用于专门处理树结构递归操作上存在，但是一般的基于 List 相关的业务处理，更多用到的还是容器自身的机制，非必要不使用组合模式。
### [享元模式](dp-composite-flyweight.md#享元模式) 
享元在性能敏感场景专用，其基本思想已经被编程原则吸收，进入各层级的最佳实践中。在形式上也轻量化为不可变对象实现。
### [解释器模式](dp-command-iterator-interpreter.md#解释器模式) 
解释器模式仍在 DSL 中使用，进行解释生成工具、组合式函数等步骤。
