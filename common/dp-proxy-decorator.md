---
title: 代理模式与装饰器模式
tags:
  - common
  - design-pattern
  - proxy
  - decorator
---
## 概述
代理模式和装饰器模式在原始的结构上是相似的，都是以组合持有一个对象，并且对外暴露的接口保持和原有一致，在这基础上进行增强功能（尽管在很多地方认为代理的权限控制不算是一种功能扩展，但从工程视角来看，增加权限控制本身就是一种功能增强）。两者是在增强功能的偏向不同，代理模式主要目的是进行控制访问，包含对象的创建、访问时机、访问权限等内容，装饰器模式主要对实现的行为进行增强，偏向业务逻辑实现，比如 IO 流、日志增强、性能统计等。
## 代理模式
代理模式的核心目的是为另一个对象提供一种代理以控制对它的访问。与装饰器模式不同的在于代理模式值进行控制访问、生命周期管理、缓存等，不增强具体的业务行为。在实现层面有静态代理和动态代理之分。
### 静态代理
静态代理就是在编译期就已经实现了相关的代理结构。
```java
class UserServiceProxy implements UserService {
    private UserService target;
	
    public void foo() {
        log();
        target.foo();
    }
}
```
但是也存在比如类爆炸、无法组合、无法按条件启用、与容器无关等问题。
### 动态代理
动态代理将方法调用从编译期绑定推迟到运行期解释，其作用对象变为了实例对象而不是类本身。
```
proxy.foo()
 ↓
InvocationHandler / Proxy handler
 ↓
判断逻辑
 ↓
调用 target.foo()
```

```java
UserService proxy = (UserService) Proxy.newProxyInstance(
    loader,
    new Class[]{UserService.class},
    (proxy, method, args) -> {
        log();
        return method.invoke(target, args);
    }
);
```
## 装饰器模式
装饰器不是为了解决不能用的问题，而是为了解决不想改却要增强的问题。典型场景就是日志、权限校验、事务、缓存等。在这些场景里，如果不使用装饰器，只能在业务的基础上直接修改类、使用继承、拷贝代码这些实现都不可维护。装饰器解决的是在不修改、不继承的前提下，组合行为。关键是装饰器和被装饰对象，是同一个接口类型。
```
Component（接口）
    ↑
ConcreteComponent（原始实现）
    ↑
Decorator（持有 Component）
    ↑
ConcreteDecorator（增强行为）
```
而在当今有两种实现，一种是显式的实现，一种是以语言机制为驱动的隐式的实现。
### 显式实现
显式实现以组合进行，这是最原始的装饰器模式，保持类似 `new A(new B())` 的嵌套包裹结构。
```java
class XxxDecorator implements Service {
    private final Service delegate;
}
```
Java 的 IO 流仍然保留着装饰器风格的实例设计。这种结构使得每一层只做一件事，而且层数不多没有产生爆炸问题。
```java
InputStream in =
    new BufferedInputStream(
        new DataInputStream(
            new FileInputStream(file)
        )
    );
```
## 隐式实现
由于装饰器模式可以多层嵌套的特性导致了手写嵌套关系有失控的风险，所以现在的装饰器模式都是以框架和语言层级存在的，通过自动的生成来执行这种嵌套，而使用者通过一系列的声明进行管理，使得整体流程变得可控。由于各个语言实现装饰器模式的具体机制和语法并不同，这里不展开说明，但在编程风格上以两种为主，如下。但整体而言，一般都是以 `@Xxx` 形式进行声明。
- 以 Java 为代表的基于框架的实现，通过注解 + 框架实现。
- 以函数式编程为主的，如 Python 、Kotlin 、TypeScript 等，以函数的包裹实现，一般是语言级别的机制，更为详细的机制各有不同。
## 工程现状
## 概述
两者在现代工程中的具体形式差别很大，主要是语言特性上的变化。代理模式在现代工程中更偏向动态代理，而装饰器模式通常都基于 `@` 符号为声明的语言机制。以下是一些细碎的工程现状。
- 代理模式一般在业务层面几乎见不到，因为业务逻辑关心的是做什么，代理解决的是怎么被调用的问题，业务代码中显式写代理，往往是坏味道。
- 装饰器具有不可替代性。行为组合这个问题依然存在，而且越来越严重。所以装饰器模式至今仍未淘汰，仍然广泛使用。
- 而但在一些具体实现中仍有语义重叠，比如在 Spring 的很多代理实际上承担了很多装饰器的职责，尤其是 Java 的动态代理方法 `invoke` 权限极高，甚至可以修改入参和返回，从事实上作为一个通用的办法拦截器；AOP 从意图上是装饰，但是到具体实现时是通过代理实现的。
### AOP
AOP 本身是装饰器思想的实现，但是在实现上往往都借助着代理模式实现。因为无法在运行时，把装饰器直接塞进一个已经被创建出来的对象里。Java 的限制决定了对象一旦创建，方法调用已经绑定，就无法在外部插入一层调用逻辑。于是只能退一步用一个代理对象，拦截调用，再转发给真实对象。代理在 AOP 中是手段而不是目的。
```
Client
  ↓
Proxy  ←—— AOP 生效点
  ↓
Target
```
在框架中，代理是基础设施，用来承载横切能力。尤其是涉及到 DI 容器的设计，几乎所有语言多多少少都使用了代理机制，这是为了实现容器内对象的生命周期管理。尽管是一些轻量的 DI 容器也使用了代理，只是被语法糖隐藏起来了，如 NestJS 。
