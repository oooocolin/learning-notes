---
title: 异常处理
tags:
  - common
  - exception
---
## 一、概述
一般而言，在软件编写后执行总会遇到各种问题，有些是可以避免的，有些是无法使用代码避免的，所以需要针对类别进行分别处理。一般的分类如下：
- Error （无法解决的严重问题，如资源耗尽等，一般被称为 **错误** ）
- Exception （因编程错误或其他偶然外在因素导致的一般性问题，如数组角标越界等，一般被称为 **异常** ）。
	- 编译时异常是指编译器要求必须处理的异常，一般而言就是外界因素造成的一般性异常。
	- 运行时异常是指编程时出现的逻辑问题，写代码时应尽量避免，但是往往无法消除，需要做的就是及时捕获及时处理。
## 二、异常处理机制
### 1. 捕获异常
一般而言所有语言的基本的处理异常的结构都是 `try-catch-finally` 结构，以 Java 为例，语法框架如下：
```java
try{
	// 可能产生异常的代码
} catch(Exception1 e) {
    // 产生异常的处理措施
} catch(Exception2 e) {
    // 产生异常的处理措施
} finally {
    // 无论是否发生异常，都会执行本代码
}
```
### 2. 异常的抛出
在捕获到异常后较为常见的做法就是向上抛出，在 Java 中使用 `throw` 关键字手动抛出。
```java
throw new Exception("输入的数据不合法！")
```
但是一般而言，单纯的不断抛出只会使得程序终止执行，这虽然也算是一种异常处理方法，这在程序员个人使用的工具和开发时很常用，但是在一个成熟的软件或是用户使用的软件，这种操作应该尽量避免或是不可接受。所以一般而言，异常的处理还需遵循最佳实践。
## 三、最佳实践
### 1. 自定义异常类
一般而言，语言内置的异常类，不能很好的反应具体的异常情况和具体的业务场景以及层次不明确。在实际项目中总是需要自己封装异常类以及向前端交互的异常反馈情况数据结构。同时，自定义异常类还可以根据需要自行封装异常的上下文信息，能帮助我们更为合理和优雅地处理异常。简单示例如下：
```java
// 统一的基础异常类
public class BaseException extends RuntimeException {
    private String errorCode;
	
    public BaseException(String message) {
        super(message);
    }
	
    public BaseException(String errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }
	
    public String getErrorCode() {
        return errorCode;
    }
}

// 业务异常
public class BusinessException extends BaseException {
    public BusinessException(String message) {
        super("BUSINESS_ERROR", message);
    }
}
```
### 2. 分层责任划分
由于实际项目中一般都有采用分层架构使各层结构明确，责任清晰，同时也要求了各层的异常处理也该划分相对应的责任。现按照“驱动层 -> 数据访问层 -> 业务逻辑层 -> 控制层 -> UI层” 的常见分层，并以数据库查找出现的异常为例解析责任划分的最佳实践。
#### (1). 驱动层
- 功能：在数据库中提供最基础的连接、执行 SQL 、获取结果的功能。
- 常见异常：连接超时、SQL 语法错误、类型错误等。
- 处理策略：只负责检测并抛出，不做处理（驱动层不知道业务语义，无法判断是重试还是放弃）。
#### (2). 数据访问层
- 功能：封装具体的数据库插入、更新、删除、查询访问逻辑。
- 常见异常：找不到数据、数据库连接池失效、SQL执行错误、临时网络问题。
- 处理策略：
	- 可以恢复的，如临时网络连接超时等，重试几次，若仍失败则抛出；
	- 可以处理的，如查询结果为空，则在本层处理，如返回空值或上报业务层（一般形式是向上抛出异常，而不是直接返回最终 Result 给前端）；
	- 不能处理的，封装后重新抛出，让上层处理。
#### (3). 业务逻辑层
- 功能：执行具体业务逻辑，如用户注册、下单、结算等操作。
- 常见异常：用户不存在、插入数据失败、余额不足、数据一致性冲突。
- 处理策略：
	- 大部分可以恢复的，如用户不存在、重复注册，则在本层封装语义异常上报上层；
	- 不能处理的系统不可恢复，如数据库连接失败、系统配置错误，则记录日志、警报上层，让上层处理。
#### (4). 控制层与UI层
控制层应该和 UI 层配合，控制层负责封装好最终的结果发送给前端，而前端做好用户交互友好的实现。现实实现中一个软件不应该轻易的终止，所以控制和 UI 层应该捕获底层传来的异常将他转化为弹窗、提醒等 UI 交互反馈给用户，而不是传导到顶层任其终止程序运行。  同时，由于要尽量使控制层干净，所以在实践中往往不直接在控制层和 UI 层增加 `try-catch` 块，而是使用全局异常处理器来统一处理。
#### (5). 总结与注意
在实际架构中，底层通常会在其职责范围内对异常进行局部处理，例如通过逻辑操作、资源清理或默认值恢复，尽量减少异常对系统的影响。但这并不意味着异常可以完全吞掉。业务层或其他上层仍需要获取异常的语义信息，以便在顶层完成最终处理，例如 UI 层的用户提示或统一的返回响应。  
因此，一般的做法是：底层进行必要的逻辑处理后，将异常或其语义继续向上传递。这种方式与“完全抛出不处理”不同，因为底层已经在可控范围内做了局部处理，而顶层负责统一的反馈或最终处理。
### 3. 全局异常处理器
全局异常处理器是接收所有底层反馈回来的所有异常，转化为统一或特定的数据信息。一般来说软件系统维护两类全局异常处理。一个是业务层的全局异常处理器，用于统一处理业务层面的异常处理，业务异常通常在这里“结束”不再上抛给系统，一般位于控制层和前端之间，将所有业务异常处理反馈结果给前端；另一个是系统全局异常处理器，一般是位于软件主程序入口，用于捕获系统异常、程序崩溃以及 UI 异常，如数组越界、线程异常等，一般形式是记录日志，上报监控，可选择弹窗提示或安全退出，但不干预业务逻辑，系统异常在这里终结。  
全局异常处理器本质上就是在特定位置的 `try-catch` 块，统一处理反馈，简洁控制层的书写，从形式上是接收所有异常处理，实际上在传统责任划分的话其实是属于控制层的责任范围（业务全局异常处理器）。有些框架为了实现更优雅的全局异常处理器可以配合装饰器、注解、AOP 等实现更为优雅的效果（底层的也可以使用类似操作）。
### 4. 与日志合理配合
异常处理本身就带有一定的信息，这和日志的功能部分重合，所以需要根据层次配合异常处理适当取舍才能不使得信息冗余，造成额外维护负担。下面简易记录在异常处理外日志补充在各层的取舍：
- 驱动层：
	- 不建议频繁记录每次 SQL 成功的信息（会淹没日志）；
	- 可以在异常记录时记录 SQL 、参数、异常信息；
	- debug 模式下可选打印执行时间等性能指标。
- DAO：
	- 可选在这里不重复记录错误（如果已经在驱动层打了日志）；
	- 只在逻辑上有意义的加日志，如结果为空、数据不一致、字段异常。
- Service：
	- 偏向异常处理，可选日志记录，不含有底层堆栈；
	- 记录业务过程、关键路径、输入输出；
	- 捕获 DAO 层异常，结合业务上下文记录；
	- 不记录 SQL 细节，只关注业务失败的原因。
- Controller：一般不记录日志和异常，保持干净。
- 全局异常处理器：
	- 记录最终异常，含堆栈信息；
	- 一般不再向上抛出异常，而是转化为特定数据结构，提供给前端解析。
在开发调试中日志以控制台为主，文件输出重要内容；测试时期，两者并重；生产环境中以文件系统输出为主，控制台可选。

