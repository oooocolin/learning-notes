---
title: C++ 的类
tags:
  - cxx
  - OOP
---
## 基本语法
```cpp
class Student {
	private:
		int id; // 私有数据成员
		string name; // 私有数据成员
		
	public:
		// 公有成员函数，用于设置私有数据成员
		void setData(int studentId, string studentName) {
			id = studentId;
			name = studentName;
		}
		
		// 公有成员函数，用于显示私有数据成员
		void display() {
			cout << "ID: " << id << ", Name: " << name << endl;
		}
};
```
## 特殊成员
### 构造函数
C++ 规定类的成员对象，在进入构造函数体 `{}` 之前就必须完成初始化，所以构造函数函数体其实是以赋值的方式来完成初始化参数的赋予的。C++ 对构造和赋值进行了明显的区分，而其他语言。如 Java ，将创建和初始化封装成一个黑箱步骤，不需要考虑精确的细节。  
但由此一些特殊成员对象不能进行二次赋值所以函数体式的初始化方法不适用于 `const` 成员、引用成员、没有默认构造函数的对象，这就可以使用构造函数初始化列表。
```cpp
class A {
    const int x;
public:
    A(int v) : x(v) {}  // 必须这样
};
```
### 析构函数
析构函数的主要职责是清理对象内部的资源，不是释放对象本身占用的内存，作用在于对象被销毁之前。形式为 `~` 符号跟上类名，如 `~Student()` 是无参无返回值（不是空值 `void`）的方法。
### 友元函数
C++ 提供了一种灵活跳过类属性权限的解决方案——友元机制。利用 `friend` 关键字，我们可以将特定的函数或类声明为类的友元，这些函数或类就能够访问类的私有和受保护成员，即使它们不属于该类。
```cpp
// Student.h
class Student {
	friend int getId(Student* student);
	...
}

// Syudent.cpp
int getId(Student* student)
{
	return student->id;
}

// main.cpp
Student* stu = new Student();
std::cout << "stu's id: "<< getId(stu) << std::endl;
```
**注意**：
- 从使用场景上，和其他现代语言的类的 Getter/Setter 方法相似。但是其他使用的是 Getter/Setter ，而不是沿用 C++ 的友元机制，这得追溯到 C++ 早期的设计理念。
	- C++ 是在 C 语言基础上演化而来，目标是在不损失性能的情况下，引入类和抽象，遵循让程序员能精确控制封装的边界，而不是由语言强制的理念，所以诞生了临时打破原有封装的友元机制。
	- 而现代语言选择的路线是受控访问、内部封装，设计得更为规范化。选择采用 “与其临时打破封装，不如提前定义清晰的访问通道” 的理念，通过 Getter/Setter 方法控制访问逻辑，而不是信任某个函数能访问私有变量，这也更为安全，也更易维护。也使得相比友元这种方法灵活性稍差一些，性能稍低一些（现代编译器下几乎无影响），代码层次多一些。
- 友元函数常见的入参都是指针形式，这是因为一般友元函数常用于类之间的深度协作，这些一般使用指针传递。普通对象也可作为友元函数入参，若想兼得可以使入参为应用类型，如 `Student&` 。
### 虚函数
虚函数允许派生类重写基类中的函数，从而在运行时通过基类指针或引用调用派生类的函数。需要在类方法或类方法的声明前加上 `virtual` 关键字，添加了这个关键字的函数则是虚函数，如果函数没有实现具体的逻辑则被成为纯虚函数（设置为 `= 0`）。C++ 的这个机制是用来实现运行时多态、实现抽象类和接口的，类内有实现的虚函数则可以实现运行时多态（普通的类继承只有编译多态，父类指针永远调用父类实现的方法），类内存在至少一个纯虚函数的就是抽象类，类内的方法全都是纯虚函数的被当作接口（因为 C++ 内没有 `interface` 关键字，这个本质上也还是抽象类）。
```cpp
class Student {
	private:
		int id;
		string name;
		
	public:
		// 虚函数
		virtual void setData(int studentId, string studentName) {
			id = studentId;
			name = studentName;
		}
		
		// 纯虚函数
		virtual void display() = 0;
};
```
以上的示例存在一个纯虚函数，不能实例化，是抽象类，但类中其他都是虚函数的实现，一般这种类都是作为基类，提供主线规范和默认实现。
## 实例对象
### 创建对象
C++ 创建对象有两种，区别是一个在栈上创建，一个在堆上创建对象。
#### (1). 在栈创建
在栈创建是使用声明的方式创建对象，这样会根据构造器创建，默认则是使用无参构造器创建，若想有参创建则在后面跟上括号输入参数。使用栈创建的对象由编译器自动分配、回收内存，无需使用 `delete` 来进行手动释放内存。
```cpp
Student stu;  // 等价于 Student stu = Student();
stu.setData(1, "LiHua");
```
**注意**：
- 括号实现有参创建对象是允许的`Student stu(1, "LiHua");` ，但 `Student stu();` 在实际中是错误的，虽然这一步可以通过编译，但会被当做函数声明，后续无法使用 `stu` 作为类对象进行操作，只能使用 `Student stu;` 或是 `Student stu{};` 列表化创建（也可以列表化有参构建）。
#### (2). 在堆创建
在堆创建是使用 `new` 创建，同样使用对应构造器创建对象，只是在堆上创建，返回的是对象指针。由于是在堆上创建，内存需要程序员手动释放或是程序执行完毕后释放。如果不主动释放不使用的内存就会造成内存泄漏。
```cpp
Student* stu1 = new Student();
```
### 访问属性
- 对于类成员方法访问普通成员属性使用 `this -> id` 或直接使用 `id` （注意入参命名的冲突，不能 `id = id`）；
- 对于类成员方法访问静态成员（类属性）使用 `Student::id` ；
- 对于类对象（栈创建）访问成员属性和成员方法使用 `.` 进行访问或执行；
- 对于类对象指针（堆创建）访问成员属性和成员方法使用 `->` 进行访问或执行。
**注意**：
- 直接使用 `id` 时要注意入参命名的冲突，不能 `id = id`，这样实际上是没有成功赋值（不报错）。
- 访问普通成员属性也是可以使用 `Student::id` ，实际上会等效于使用 `this -> id` ，但不推荐这么做。
## 面向对象编程（OOP）
### 继承
继承是面向对象编程中的一个核心特性，它允许一个类基于另一个类来定义自己，从而复用代码和扩展功能。C++ 类允许多重继承。
```cpp
class Base {
public:
    void sayHello() {
        std::cout << "Hello from Base" << std::endl;
    }
};

class Derived : public Base {  // public 表示公有继承
public:
    void sayHi() {
        std::cout << "Hi from Derived" << std::endl;
    }
};
```
C++ 提供三种继承方式，影响成员访问权限，与其他语言类似，只是 C++ 的继承方式仅作用于继承关系本身，像 Java 类似的语言作用于类本身。此外继承方式影响向上转型的权限，`public` 继承允许派生类对象无条件向上转型到基类对象，`protected` 允许派生类内转型 `Base* p = this;`，不允许类外转型，而 `private` 只能在自身内部向上转型。
## 现代 C++ 类特殊成员定义策略 —— 零三五法则
### C++ 特殊成员
C++ 有 6 个编译器会自动生成（如果没写）的特殊成员函数，一般讨论对象是除了默认构造函数的剩下五个特殊成员。
- 默认构造函数：`Class()` 
- 析构函数：`~Class()` 
- 拷贝构造函数：`Class(const Class&)` 
- 拷贝赋值运算符：`Class& operator=(const Class&)` 
- 移动构造函数（C++11+）：`Class(Class&&)` 
- 移动赋值运算符（C++11+）：`Class& operator=(Class&&)` 
### 零三五法则
简而言之，零三五法则就是由编译器自动生成，不由自己编写特殊成员定义数量的策略。零法则是没有显式定义任何特殊成员函数，都由编译器自动生成最合理的版本；三法则是对析构函数、拷贝构造函数以及拷贝赋值函数一起书写，而不是选择其他任意一个和任意两个；五法则就是在 C++11 引入移动语义后，如果你定义了上面三个，通常还要考虑移动构造函数和移动赋值运算符。
```cpp
// 零法则：不用写任何特殊函数，拷贝/赋值/析构都能用
struct A {
    int x;
    double y;
};
```
### 最佳实践
现代 C++ 提倡零法则，即让编译器自动生成这五类五类特殊成员函数。要实现这一点就要求尽量不要手动管理资源，使用智能指针、`std::vector`、`std::string` 等容器，这样编译器生成的五类特殊函数就不会重复释放或泄漏问题。
