---
title: CXX 基础知识
tags:
  - cxx
---
## 一、头文件和源文件
### 1. 概述
C++ 中头文件主要用于声明接口，而源文件包含具体的实现代码。这种分离提供了编译效率和模块化管理的优势。头文件以 `.h` 结尾，不参与编译过程只提供声明集合，可提供多个源文件共享，使用 `#include` 引用。
### 2. 头文件的内容
头文件应包以下内容：
- 类的声明，包括数据成员和成员函数的声明。
- 函数原型，即函数的声明。
- 宏定义，如 `#define` 常量。
- `extern` 关键字声明的全局变量，表示变量在其他地方定义。
- `inline` 函数的定义，因为它们需要在编译时展开。
- 模板定义，包括类模板和函数模板。
头文件中不应该包含：
- 函数的具体实现（除非是 `inline` 函数）。
- 可以被多次定义的符号，如非 `const` 的全局变量。
为了防止头文件被多次包含，导致重复定义的问题，通常在头文件的开头和结尾使用预编译指令。这些指令告诉编译器，如果头文件已经被包含过，则忽略其内容。这通常通过 `#ifndef`，`#define` 和 `#endif` 指令来实现。
```cpp
#ifndef MATH_H
#define MATH_H

// 头文件内容

#endif // MATH_H
```
### 3. 头文件与源文件的关联
当编译器编译一个源文件时，它不会直接查找与头文件相关联的其他源文件。相反，它依赖于链接器在链接阶段解析外部符号。例如，如果 `main.cpp` 包含了 `math.h`，并且使用了在 `math.cpp` 中定义的函数，那么在编译 `main.cpp` 时，编译器只关心函数的声明。在链接阶段，链接器会查找 `math.cpp` 生成的目标文件来解析这些函数的定义。
## 二、类
### 1. 结构
```cpp
class Student {
	private:
		int id; // 私有数据成员
		string name; // 私有数据成员
		
	public:
		// 公有成员函数，用于设置私有数据成员
		void setData(int studentId, string studentName) {
			id = studentId;
			name = studentName;
		}
		
		// 公有成员函数，用于显示私有数据成员
		void display() {
			cout << "ID: " << id << ", Name: " << name << endl;
		}
};
```
### 2. 创建对象
C++ 创建对象有两种，区别是一个在栈上创建，一个在堆上创建对象。
#### (1). 在栈创建
在栈创建是使用声明的方式创建对象，这样会根据构造器创建，默认则是使用无参构造器创建，若想有参创建则在后面跟上括号输入参数。使用栈创建的对象由编译器自动分配、回收内存，无需使用 `delete` 来进行手动释放内存。
```cpp
Student stu;  // 等价于 Student stu = Student();
stu.setData(1, "LiHua");
```
**注意**：
- 括号实现有参创建对象是允许的`Student stu(1, "LiHua");` ，但 `Student stu();` 在实际中是错误的，虽然这一步可以通过编译，但会被当做函数声明，后续无法使用 `stu` 作为类对象进行操作，只能使用 `Student stu;` 或是 `Student stu{};` 列表化创建（也可以列表化有参构建）。
#### (2). 在堆创建
在堆创建是使用 `new` 创建，同样使用对应构造器创建对象，只是在堆上创建，返回的是对象指针。由于是在堆上创建，内存需要程序员手动释放或是程序执行完毕后释放。如果不主动释放不使用的内存就会造成内存泄漏。
```cpp
Student* stu1 = new Student();
```
### 3. 访问属性
- 对于类成员方法访问普通成员属性使用 `this -> id` 或直接使用 `id` （注意入参命名的冲突，不能 `id = id`）；
- 对于类成员方法访问静态成员（类属性）使用 `Student::id` ；
- 对于类对象（栈创建）访问成员属性和成员方法使用 `.` 进行访问或执行；
- 对于类对象指针（堆创建）访问成员属性和成员方法使用 `->` 进行访问或执行。
**注意**：
- 直接使用 `id` 时要注意入参命名的冲突，不能 `id = id`，这样实际上是没有成功赋值（不报错）。
- 访问普通成员属性也是可以使用 `Student::id` ，实际上会等效于使用 `this -> id` ，但不推荐这么做。
### 4. 析构函数
析构函数的主要职责是清理对象内部的资源，不是释放对象本身占用的内存，作用在于对象被销毁之前。形式为 `~` 符号跟上类名，如 `~Student()` 是无参无返回值（不是空值 `void`）的方法。
### 5. 友元函数
C++ 提供了一种灵活跳过类属性权限的解决方案——友元机制。利用 `friend` 关键字，我们可以将特定的函数或类声明为类的友元，这些函数或类就能够访问类的私有和受保护成员，即使它们不属于该类。
```cpp
// Student.h
class Student {
	friend int getId(Student* student);
	...
}

// Syudent.cpp
int getId(Student* student)
{
	return student->id;
}

// main.cpp
Student* stu = new Student();
std::cout << "stu's id: "<< getId(stu) << std::endl;
```
**注意**：
- 从使用场景上，和其他现代语言的类的 Getter/Setter 方法相似。但是其他使用的是 Getter/Setter ，而不是沿用 C++ 的友元机制，这得追溯到 C++ 早期的设计理念。
	- C++ 是在 C 语言基础上演化而来，目标是在不损失性能的情况下，引入类和抽象，遵循让程序员能精确控制封装的边界，而不是由语言强制的理念，所以诞生了临时打破原有封装的友元机制。
	- 而现代语言选择的路线是受控访问、内部封装，设计得更为规范化。选择采用 “与其临时打破封装，不如提前定义清晰的访问通道” 的理念，通过 Getter/Setter 方法控制访问逻辑，而不是信任某个函数能访问私有变量，这也更为安全，也更易维护。也使得相比友元这种方法灵活性稍差一些，性能稍低一些（现代编译器下几乎无影响），代码层次多一些。
- 友元函数常见的入参都是指针形式，这是因为一般友元函数常用于类之间的深度协作，这些一般使用指针传递。普通对象也可作为友元函数入参，若想兼得可以使入参为应用类型，如 `Student&` 。
### 6. 虚函数
虚函数允许派生类重写基类中的函数，从而在运行时通过基类指针或引用调用派生类的函数。需要在类方法或类方法的声明前加上 `virtual` 关键字，添加了这个关键字的函数则是虚函数，如果函数没有实现具体的逻辑则被成为纯虚函数（设置为 `= 0`）。C++ 的这个机制是用来实现运行时多态、实现抽象类和接口的，类内有实现的虚函数则可以实现运行时多态（普通的类继承只有编译多态，父类指针永远调用父类实现的方法），类内存在至少一个纯虚函数的就是抽象类，类内的方法全都是纯虚函数的被当作接口（因为 C++ 内没有 `interface` 关键字，这个本质上也还是抽象类）。
```cpp
class Student {
	private:
		int id;
		string name;
		
	public:
		// 虚函数
		virtual void setData(int studentId, string studentName) {
			id = studentId;
			name = studentName;
		}
		
		// 纯虚函数
		virtual void display() = 0;
};
```
以上的示例存在一个纯虚函数，不能实例化，是抽象类，但类中其他都是虚函数的实现，一般这种类都是作为基类，提供主线规范和默认实现。
## 三、模板
### 1. 概述
模板用于编写与数据类型无关的代码，是 C++ 中实现泛型的基础，避免方法因为类型而多次重载，提高代码复用率。模板的背后原理是通过编译器根据传入类型生成具体函数的版本，在调用时调用具体的实现。模板分为函数模板和类模板。
### 2. 语法结构
函数模板：
```cpp
// 泛型函数模板
template <typename T>
T add(T a, T b) {
    return a + b;
}

int main() {
    cout << add(2, 3) << endl;       // int
    cout << add(2.5, 3.7) << endl;   // double
}
```
类模板：
```cpp
template <typename T>
class Box {
    T value;
public:
    Box(T v) : value(v) {}
    T get() { return value; }
};

int main() {
    Box<int> intBox(10);      // T = int
    Box<double> doubleBox(3.14);  // T = double

    cout << intBox.get() << endl;
    cout << doubleBox.get() << endl;
}
```
### 3. 特化及偏特化
模板函数和模板类需要对传入的不同类型进行不同的处理，是针对某些类型或是某些类型模式专门写一个实现。具体而言，有全特化和偏特化之分。  
- **全特化**：模板类型里的所有类型参数全部具体指明之后处理。`template<>` 中为空，代表所有类型都在下面特殊化处理。
- **偏特化**：模板类型里的局部类型参数进行具体指明，仍保留一部分泛化类型。
```cpp
// 全特化
template<>
struct A<int,int> {
	A(){ cout<<"int, int特化版本构造函数"<<endl; } 
	void func() { cout<<"int,int特化版本"<<endl; } 
};

// 对指针类型的偏特化
template <typename T>
struct TypeInfo<T*> {
    static void print() {
        cout << "指针类型" << endl;
    }
};
```
**注意**：
- 对于函数模板没有偏特化。因为模板会自动进行重载，这相当于语义上支持更特定版本，支持偏特化的话会与重载冲突。
- 模板特化与其他语言的泛型类型约束不同。模板本身不能限制类型，只能对特定类型进行特定逻辑的实现，而泛型类型约束可以约束实现的类型。若需要限制类型需要使用 C++ 11/17 以后的约束机制。
- 模板特化需要保留最通用的那个模板，因为特化本质上只是一种实现而已。
### 4. 注意
由于 C++ 模板是在编译器在编译期间静态创建模板实现的，所以模板不存在其他静态类型语言实现泛型的泛型擦除问题（由于 Java、C# 泛型是在编译期做类型检查，运行时将类型擦除为 Object 类型）。
## 四、引用
### 1. 概述
在 C++ 语言层面上，引用（`T&`）只是某个已有对象的另一个名字。虽然语义上是别名，但编译器底层往往会用一个指针（隐式的）来实现引用。引用一旦建立无法变更绑定关系，后续操作都视为给绑定对象赋值。
```cpp
int a = 10;
int& r = a;
r = 20;
```
### 2. 与指针的不同
| 特性              | 指针 (`int* p`) | 引用 (`int& r`)  |
| --------------- | ------------- | -------------- |
| 是否可以为 `nullptr` | 可以            | 不行             |
| 是否可以重新绑定        | 可以（`p = &b;`） | 不行             |
| 是否需要显式解引用       | 需要（`*p`）      | 不需要（`r` 就是原对象） |
| 实现上             | 显式指针          | 编译器自动生成隐藏指针    |
## 3. 与 `const` 的结合
`const` 的作用是限制通过当前名字修改对象的能力，即赋值、调用非 `const` 成员函数、取非 `const` 引用等。`const` 与引用结合使得无法通过该引用修改值，但引用对象本身依然可以修改。
```cpp
int a = 10;
const int& r = a;
r = 20;  // 错误：不能通过 r 修改 a

a = 30;   // OK
```
## 五、语言链接
`extern` 不仅作为存储类说明符，提供全局变量/函数的声明，还可以用作语言链接说明符，指示编译器按照指定语言的风格导出指定接口。其目的是使对外显示的接口命名统一且可识别，方便其他语言调用。以下使用 C 语言方式导出。
```cpp
extern "C" { ... }
```
**好处**：
- 避免 C++ 重整符号名（name mangling）。
- 使 DLL 对其他语言兼容性更好。
- 常用于 DLL 接口、回调接口、与 C 程序交互。
```cpp
extern "C" {
#define DLL_EXPORTS __declspec(dllexport)    
	DLL_EXPORTS  int mainFunction(...);    /* 要作为DLL接口的函数 */
}
```






