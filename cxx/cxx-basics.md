---
title: CXX 基础知识
tags:
  - cxx
---
## 一、头文件和源文件
### 1. 概述
C++ 中头文件主要用于声明接口，而源文件包含具体的实现代码。这种分离提供了编译效率和模块化管理的优势。头文件以 `.h` 结尾，不参与编译过程只提供声明集合，可提供多个源文件共享，使用 `#include` 引用。
### 2. 头文件的内容
头文件应包以下内容：
- 类的声明，包括数据成员和成员函数的声明。
- 函数原型，即函数的声明。
- 宏定义，如 `#define` 常量。
- `extern` 关键字声明的全局变量，表示变量在其他地方定义。
- `inline` 函数的定义，因为它们需要在编译时展开。
- 模板定义，包括类模板和函数模板。
头文件中不应该包含：
- 函数的具体实现（除非是 `inline` 函数）。
- 可以被多次定义的符号，如非 `const` 的全局变量。
为了防止头文件被多次包含，导致重复定义的问题，通常在头文件的开头和结尾使用预编译指令。这些指令告诉编译器，如果头文件已经被包含过，则忽略其内容。这通常通过 `#ifndef`，`#define` 和 `#endif` 指令来实现。
```cpp
#ifndef MATH_H
#define MATH_H

// 头文件内容

#endif // MATH_H
```
### 3. 头文件与源文件的关联
当编译器编译一个源文件时，它不会直接查找与头文件相关联的其他源文件。相反，它依赖于链接器在链接阶段解析外部符号。例如，如果 `main.cpp` 包含了 `math.h`，并且使用了在 `math.cpp` 中定义的函数，那么在编译 `main.cpp` 时，编译器只关心函数的声明。在链接阶段，链接器会查找 `math.cpp` 生成的目标文件来解析这些函数的定义。
## 二、类
### 1. 结构
```cpp
class Student {
	private:
		int id; // 私有数据成员
		string name; // 私有数据成员
		
	public:
		// 公有成员函数，用于设置私有数据成员
		void setData(int studentId, string studentName) {
			id = studentId;
			name = studentName;
		}
		
		// 公有成员函数，用于显示私有数据成员
		void display() {
			cout << "ID: " << id << ", Name: " << name << endl;
		}
};
```
### 2. 创建对象
C++ 创建对象有两种，区别是一个在栈上创建，一个在堆上创建对象。
#### (1). 在栈创建
在栈创建是使用声明的方式创建对象，这样会根据构造器创建，默认则是使用无参构造器创建，若想有参创建则在后面跟上括号输入参数。使用栈创建的对象由编译器自动分配、回收内存，无需使用 `delete` 来进行手动释放内存。
```cpp
Student stu;  // 等价于 Student stu = Student();
stu.setData(1, "LiHua");
```
**注意**：
- 括号实现有参创建对象是允许的`Student stu(1, "LiHua");` ，但 `Student stu();` 在实际中是错误的，虽然这一步可以通过编译，但会被当做函数声明，后续无法使用 `stu` 作为类对象进行操作，只能使用 `Student stu;` 或是 `Student stu{};` 列表化创建（也可以列表化有参构建）。
#### (2). 在堆创建
在堆创建是使用 `new` 创建，同样使用对应构造器创建对象，只是在堆上创建，返回的是对象指针。由于是在堆上创建，内存需要程序员手动释放或是程序执行完毕后释放。如果不主动释放不使用的内存就会造成内存泄漏。
```cpp
Student* stu1 = new Student();
```
### 3. 访问属性
- 对于类成员方法访问普通成员属性使用 `this -> id` 或直接使用 `id` （注意入参命名的冲突，不能 `id = id`）；
- 对于类成员方法访问静态成员（类属性）使用 `Student::id` ；
- 对于类对象（栈创建）访问成员属性和成员方法使用 `.` 进行访问或执行；
- 对于类对象指针（堆创建）访问成员属性和成员方法使用 `->` 进行访问或执行。
**注意**：
- 直接使用 `id` 时要注意入参命名的冲突，不能 `id = id`，这样实际上是没有成功赋值（不报错）。
- 访问普通成员属性也是可以使用 `Student::id` ，实际上会等效于使用 `this -> id` ，但不推荐这么做。
### 4. 析构函数
析构函数的主要职责是清理对象内部的资源，不是释放对象本身占用的内存，作用在于对象被销毁之前。形式为 `~` 符号跟上类名，如 `~Student()` 是无参无返回值（不是空值 `void`）的方法。




