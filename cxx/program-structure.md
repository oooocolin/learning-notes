---
title: C++ 程序结构
tags:
  - cxx
---
## 头文件和源文件
### 概述
C++ 中头文件主要用于声明接口，而源文件包含具体的实现代码。这种分离提供了编译效率和模块化管理的优势。头文件以 `.h` 结尾，不参与编译过程只提供声明集合，可提供多个源文件共享，使用 `#include` 引用。
### 头文件的内容
头文件应包以下内容：
- 类的声明，包括数据成员和成员函数的声明。
- 函数原型，即函数的声明。
- 宏定义，如 `#define` 常量。
- `extern` 关键字声明的全局变量，表示变量在其他地方定义。
- `inline` 函数的定义，因为它们需要在编译时展开。
- 模板定义，包括类模板和函数模板。
头文件中不应该包含：
- 函数的具体实现（除非是 `inline` 函数）。
- 可以被多次定义的符号，如非 `const` 的全局变量。
为了防止头文件被多次包含，导致重复定义的问题，通常在头文件的开头和结尾使用预编译指令。这些指令告诉编译器，如果头文件已经被包含过，则忽略其内容。这通常通过 `#ifndef`，`#define` 和 `#endif` 指令来实现。
```cpp
#ifndef MATH_H
#define MATH_H

// 头文件内容

#endif // MATH_H
```
但在现代 C++ 下建议使用 `#pragma once` 更为简便，详见 [C++ 预处理器与宏](preprocessor-macro.md#include) 。
### 头文件与源文件的关联
当编译器编译一个源文件时，它不会直接查找与头文件相关联的其他源文件。相反，它依赖于链接器在链接阶段解析外部符号。例如，如果 `main.cpp` 包含了 `math.h`，并且使用了在 `math.cpp` 中定义的函数，那么在编译 `main.cpp` 时，编译器只关心函数的声明。在链接阶段，链接器会查找 `math.cpp` 生成的目标文件来解析这些函数的定义。
## 命名空间
命名空间是 C++ 中的一种工具，它通过为不同的标识符（例如函数、类和变量）提供命名作用域来组织代码。命名空间有助于避免名称冲突，并使代码更具模块化。通常被用来进行逻辑模块化的封装，下面可以继续嵌套命名空间。如下就可以通过 `MyLib::Graphics::Renderer` 进行使用。
```cpp
namespace MyLib {
    namespace Graphics {
        class Renderer { };
    }
    namespace IO {
        class FileReader { };
    }
}
```
同时命名空间的约束不要求像头文件与源文件声明与实现分离，即并不要求前向声明，命名空间只需具体组织结构的头文件保持命名空间命名的一致性编译器就视为同一个命名空间，IDE 一般也不会引导你组织具体的结构，顶层的命名空间头文件更像是作为一种项目管理的规范而存在的。
## [类](class.md) 

## [模板](template.md) 

